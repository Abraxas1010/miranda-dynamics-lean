import Mathlib.Order.SetNotation
import HeytingLean.Formal.Nucleus.FixedPoints
import HeytingLean.MirandaDynamics.Discrete.HaltingToPeriodic
import HeytingLean.MirandaDynamics.FixedPoint.PeriodicNucleus

/-!
# MirandaDynamics.HeytingTuring: hypothesis-first correspondence spine

This module does **not** attempt to reprove the geometric/PDE constructions from the Miranda/TKFT
literature. Instead, it packages a small, fully mechanized spine that matches the project slogan

> fixed points ↔ “stable/forced” propositions ↔ computational predicates

in a way that is directly reusable:

- a predicate `P : α → Prop` determines a nucleus on `Set α` by “union with `P`”,
- the fixed points of that nucleus form a frame (hence a Heyting-style logic of propositions),
- the predicate-set `P` can be recovered as the infimum of all fixed points (intersection of all
  supersets).

This is the level at which a “Heyting–Turing correspondence” can be stated without importing any
external analytic content: all external results are kept behind explicit interfaces elsewhere.
-/

namespace HeytingLean
namespace MirandaDynamics
namespace HeytingTuring

open Set

universe u

section PredicateNucleus

variable {α : Type u}

/-- View a predicate as a set. -/
def predSet (P : α → Prop) : Set α :=
  {x | P x}

/-- The nucleus generated by forcing membership in `predSet P`: `S ↦ S ∪ {x | P x}`. -/
def predNucleus (P : α → Prop) : Nucleus (Set α) :=
  MirandaDynamics.FixedPoint.unionNucleus (α := α) (predSet P)

theorem predNucleus_fixed_iff (P : α → Prop) (S : Set α) :
    predNucleus (α := α) P S = S ↔ predSet (α := α) P ⊆ S := by
  simpa [predNucleus, predSet] using
    (MirandaDynamics.FixedPoint.isFixedPoint_unionNucleus_iff (α := α) (predSet (α := α) P) S)

/-- The “forced predicate set” can be recovered as the infimum (intersection) of all its supersets. -/
theorem sInf_supersets_eq (U : Set α) :
    sInf {S : Set α | U ⊆ S} = U := by
  classical
  ext x
  constructor
  · intro hx
    have hx' : x ∈ ⋂₀ {S : Set α | U ⊆ S} := by
      simpa [Set.sInf_eq_sInter] using hx
    have hall : ∀ t ∈ {S : Set α | U ⊆ S}, x ∈ t :=
      (Set.mem_sInter).1 hx'
    exact hall U (by simp)
  · intro hxU
    have hx' : x ∈ ⋂₀ {S : Set α | U ⊆ S} := by
      refine (Set.mem_sInter).2 ?_
      intro S hS
      exact hS hxU
    simpa [Set.sInf_eq_sInter] using hx'

/-- For a union-nucleus `S ↦ S ∪ U`, the set `U` is determined by its fixed points. -/
theorem sInf_fixedPoints_unionNucleus_eq (U : Set α) :
    sInf {S : Set α | MirandaDynamics.FixedPoint.unionNucleus (α := α) U S = S} = U := by
  have hFix :
      {S : Set α | MirandaDynamics.FixedPoint.unionNucleus (α := α) U S = S} =
        {S : Set α | U ⊆ S} := by
    ext S
    simpa using (MirandaDynamics.FixedPoint.isFixedPoint_unionNucleus_iff (α := α) U S)
  simpa [hFix] using (sInf_supersets_eq (α := α) U)

/-- The Heyting-style logic (frame) of fixed points of the predicate nucleus. -/
abbrev PredFrame (P : α → Prop) : Type u :=
  HeytingLean.Formal.Nucleus.FixedPoints (predNucleus (α := α) P)

instance (P : α → Prop) : Order.Frame (PredFrame (α := α) P) := by
  infer_instance

end PredicateNucleus

/-! ## Concrete instance: discrete “halts ↔ reaches period-2 orbit” predicate -/

namespace DiscreteExample

open HeytingLean.MirandaDynamics.Discrete

/-- The set of codes whose induced discrete orbit reaches a period-2 point. -/
def reachesPeriod2Set (n : Nat) : Set Nat.Partrec.Code :=
  {c | ReachesPeriod2 n c}

/-- The nucleus generated by the discrete period-2 reachability predicate. -/
def period2Nucleus (n : Nat) : Nucleus (Set Nat.Partrec.Code) :=
  MirandaDynamics.FixedPoint.unionNucleus (α := Nat.Partrec.Code) (reachesPeriod2Set n)

theorem not_computable_mem_reachesPeriod2Set (n : Nat) :
    ¬ComputablePred (fun c : Nat.Partrec.Code => c ∈ reachesPeriod2Set n) := by
  simpa [reachesPeriod2Set] using (HeytingLean.MirandaDynamics.Discrete.not_computable_reachesPeriod2 n)

end DiscreteExample

end HeytingTuring
end MirandaDynamics
end HeytingLean
